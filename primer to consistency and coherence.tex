\documentclass[UTF-8]{ctexrep}
\begin{document}
\title{\textbf{A Primer on Memory Consistency and Cache Coherence}\\内存一致性与缓存同一性入门}
\author{Daniel J. Sorin, Mark D.Hill, David A.Wood \\翻译：李默 phylimo@163.com}
\date{2022.09}
\maketitle
\chapter*{\textbf{译注}}

\begin{enumerate}
\item consistency 和coherence 一般都统一译作“一致性”，即内存一致性、缓存一致性。但其实二者的“一致性”的英文单词不同，所以其“一致”内涵实际是不同的。本书使用稍微不同的翻译加以区分。
\par 前者consistency字面意思是前后一致，持续的一致，即偏重时序上的行为特点，采用常规“一致性”的译法；
\par 后者coherence 字面为协调，和谐，所以更偏重在逻辑上的行为特点，“cache coherence”的机制笼统地说是参与缓存访问的操作者在同一时刻对同一个数据观察到的是同一个值，所以更偏重在逻辑上的同数据同值，故这里译作“同一性”。
\item 如无特殊说明，“一致性”将作为缩称代指内存一致性，“同一性”将作为缩称代指缓存同一性。
\item 如无特殊说明，文中如果出现“内存系统”或“内存”，指共享内存系统和共享内存，即多个操作者（如处理器，外设等等）同时会访问操作的内存系统。
\end{enumerate}

\tableofcontents
\chapter*{摘要}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。对这样拥有共享内存的系统，它的内存一致性模型在架构上定义了它的内存组件能被观察到的行为的集合。一致性定义了读写操作的行为规则及它们如何与内存交互作用。为了实现所标称的一致性模型，一般这样的系统同时会使用特定的缓存同一性协议来保证多处缓存的数据时刻保持最新。 本入门手册的目的是为读者提供对内存一致性和缓存同一性模型的基本理解，包括技术问题与其解决方案。我们会在书中给出高度抽象的概念，同时也会给一些实际中的例子。

\chapter{内存一致性、缓存同一性简介}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。这种使用多核心、共享内存的系统设计一般是想追求高性能、低功耗、低成本等等特性。当然，如果没有了基本的正确性，那这些特性也将无价值。共享内存正确性乍看好像很简单，但实际上，正如本书将展示的，共享内存的正确性定义甚至都不是一件简单事，存在很多模糊点，更不用说实现一个“正确”的共享内存。这些问题需要在硬件实现过程弄清楚，因为修复一个硬件bug的成本是很高的。学术的人也应该弄清，明确对象，这样才能讨论某个提议的设计是否能正常工作。
\par 在实际研究中我们发现在研究内存正确性时从两维度出发将有助于问题的分析与解决：consistency 与 coherence（一致与同一，下面会对这两个概念进行定义阐述）。当然一个系统并不是必须要区分此二者，只是从我们的经验上看，此二者有助于我们将问题分解，各个击破。实际上，在内存系统实现过程中，普遍采用了这两个维度的分解方法。
\par 共享内存的正确性主要由一致性维度来定义，一致性模型定义了读写如何作用到内存的规则。理想情况下，一致性模型应该是一个简单的易于理解的模型（或规格说明）。然而，定义共享内存的正确性比定义一个单核模型（即无需考虑并发共享）下的内存的正确性要模糊、朦胧地多。在单核模型下，内存正确性很好定义，它有一个唯一正确性结果，可以与所有不正确性的行为明确区分，这是因为在单核模型下，程序的输入具有明确的输出，即使这个cpu在内部执行时可能是乱序的，我们依然可以有明确的符合程序逻辑的预期输出。但对共享内存（即可能有多个处理器核心同时读写交互），它需要考虑来自多线程的并发读写，这种情况哪种输出是正确的就不是唯一的，它可能会允许一些行为（即“正确”行为，是该内存模型下可能发生的行为），同时不允许另外一些行为（即“不正确”，是该内存模型承诺不会发生的行为）。之所以允许“一些”可能行为，而不是只允许“一种“行为，是因为在多线程并发读写的场景中无法明确这些线程在物理上孰前孰后，所以线程间可能有多种物理时序交错。这种正确性多样化使得问题变得复杂，但要想在共享内存、多核系统上编写“正确”的程序，这些问题必须要得到明确地解决。
\par 与内存一致性不同, 缓存同一性对软件是不可见的，也不需要可见。但作为支撑一致性模型的一部分，大部分共享内存计算机系统才会使用某种同一性协议（因为大多系统也都使用了缓存）。同一性的目的是为了让共享内存系统的缓存行为和单核模型下的缓存一样对外不可见，即不影响程序的功能。所以，同一性协议的目的是让用户无法从读写的数值结果上感受到缓存的存在，避免缓存的使用引入任何功能性差异（当然，程序员依然可以从时间维度上探测缓存的存在，但这不属于功能性差异）。
\par 一般来说，同一性在支撑一致性模型的过程中扮演非常重要的角色。因此，虽然一致性是本书的第一个主题，我们在第二章还是先对同一性进行一些介绍。本章先对一致性与同一性的关系进行一些必要的介绍，而不是直接深入具体的协议和实现（这些将在后面的章节6-9中探讨）。第二章中，我们先使用SWMR(单写者多读者) 不变式来定义同一性。SWMR 不变式要求在任意时间任一内存位置要么只能在一个缓存中接收写操作（同时也可以在该缓存中接收读操作），要么可以在多个缓存中接受读操作。
\section{一致性}
\par 一致性亦称内存一致性、内存一致性模型，或内存模型。一致性模型定义了什么是“正确的”内存读取写入行为，而且这里的正确性与缓存及缓存同一性无关。为了更通俗地理解为什么需要一致性模型，我们举一个现实世界的例子。比如一个大学在网上发布了它的课程表，其中计算机课程的上课地点是152教室。在上课的前一天，该大学管理人员决定将课程改至252教室上课。管理人员首先给网站管理员发送了email告诉他将网上的课程信息更新，不久后他发短信给所有注册该课程的学生告知他们课程表更新的事情。不难预见，可能会有这样一种情形：网站管理员太忙碌没有及时更新课表信息，而某位学生在接收短信后立即上网查看“新”课表，此时该学生将看到教室还是152。虽然几分钟后管理员最终将课程教室更新至了252，而且这位大学管理人员(从他的视角看)也进行了正确的“写”操作顺序，但这位学生观察到的“写”操作顺序却是不同的，导致最终去了错误的教室。一致性模型就是定义在这样的系统中这种行为表现（即管理人员先通知网络管理员更新网络，再通知学生;而学生则是先收到信息，之后才觉察网络更新）是“正确”的（此时用户需要采取其它措施以获取想要的结果），或是错误的（即系统实现将保证不会出现这种行为表现）。
\par 上述例子使用了多种信息传递介质，但类似的行为完全可能出现在同一介质的内存系统中，尤其系统组成中有多个能够乱序执行的cpu，或内存系统有write buffer，具有预取能力，或者多cache bank机制。因此，我们需要定义内存系统的正确性，即何种内存行为是被允许的，这样程序员才会根据该正确性定义对系统的输出有正确的期望，内存系统的实现者也会有一个明确的行为约束准则。
\par 内存系统正确性由内存一致性模型给出。一致性模型明确规定了多线程、共享内存环境下被允许的行为集合。对某处理某特定输入的多线程程序而言，内存模型规定了其各个读取操作可能返回的内存值，以及内存可能的最终状态。不同与单线程模式，在多线程模式下，可能有多种行为结果是被允许的，因而理解内存一致性模型也会稍微复杂。
\par 第三章介绍了内存一致性模型的概念，同时介绍“顺序一致性模型”(Sequential Consistency，SC)，这是约束最强也是最直观的一致性模型。章节伊始再次阐述了内存正确性定义的必要性，同时精确地定义什么是内存一致性模型。接着，章节深入讨论SC模型。SC模型规定，一个多线程程序运行的结果应该看起来像它的各个线程以某种时间交错方式下分时复用单核心处理器运行的结果一样，很直观、易于理解。在直观印象后，我们用形式化语言正式地对SC进行讨论，同时探索了在缓存存在的情况下简单、激进两种方式实现一个SC 模型的过程 , 最终以MIPS R10000 实例学习作为结束。
\par 第四章，我们在SC 基础上研究 x86 和 SPARC 处理器所使用的内存模型：全局写序一致性模型 (total store order, TSO) 。TSO 模型的要旨是在处理器将写操作正式提交给缓存之前，先使用一个先入先出的写缓冲区来暂存这些提交的写操作。写缓冲区的引入将违背SC模型定义，但由于TSO模型可以带来明显的性能收益，所以人们还是允许这样一种内存模型的存在并对其进行了明确定义。在该章中，我们还将探索如何用SC的形式化方法来类似地研究TSO模型，TSO模型如何影响内存系统的具体实现，以及对SC 和 TSO 进行比较。
\par 最后，在第五章我们引入弱序一致性模型（简称弱序模型）。弱序模型提出的动机是那些强约束一致性模型中对大多内存操作的序的限制是不必要的。如果一个线程更新了十项数据，然后用一个同步flag进行标记与其它线程同步，程序员其实不关心这十项数据哪项数据先更新哪项后更新，唯一关心的是同步flag的标记动作需要在十项数据更新完成后再完成。弱序模型的目标正是提供这种灵活的内存操作序以得到更高的性能或更简单的内存系统实现。阐述了动机后，我们提出了一个名为XC的弱序模型示例。在XC中，程序员只有使用FENCE指定才能得到明确的内存操作顺序，比如在数据更新和同步flag标记之间使用FENCE，以确保flag的完成在数据更新之后。之后，该章延续使用前面对SC 和 TSO 使用过的形式化方法，对XC模型进行分析，以及探讨如何实现XC (包括各种乱序、同一性协议等等)。接着我们讨论了一种很多程序员可以用来避免直接对弱序模型进行推理的做法：如果在程序中加入足够多的FENCE指令以保证程序没有数据竞争（data race free, DRF）, 那么大多弱序模型将表现地类似SC模型。 在这种无数据竞争的类“SC模型”下，程序员可以兼得（相对）SC的直观的正确性和(相对）XC的高性能。对想深入了解的读者，该章最后将"acquire/release" 做了区分，讨论了写原子性和因果性，还将涉及一些商业产品例子（包括一个 IBM Power 的例子）以及高级语言(Java和 C++)的内存模型。
\par 回想上面大学课程表的例子，我们可以看到email、网站管理员、短消息这些元素组成的系统其实是一个“弱序模型”。为了学生由于“太及时”查看短信反而去到错误教室这种情况的发生，大学管理人员需要在发送email通知网站管理员更新网页和发送短信给学生之间插入一条FENCE命令，以保证网站更新完成后学生才会收到短信。
\section{同一性}
\par 同一性即缓存同一性。在有缓存的系统中，多个内存操作者（如处理器、可直接访问内存的外设等等）同时对一块数据区进行访问而且其中有写操作时，如果不精心处理这些并发操作的交互，同一性问题将会发生。举一个与前面用过的课程表类似的例子：一位同学上网查看了课程表信息，看到上课地点是152教室（数据读取），记在了自己的本子上(数据缓存)。接着管理员将上课地点改到252教室，并及时更新了网页内容。此时，这位同学自己本子上的数据是过期的了，这时就遇到了“不同一” 的场景。如果同学到152去，他会发现进错了教室。计算机的世界里（不包括计算架构），“不同一” 的例子有网页缓存、使用未更新代码库编程等等。
\par 同一性协议就是为了避免这种获取到过期数据的情况出现，它是所有参与者都共同遵循的一系列规范。同一性协议可能有很多变种形式，但其主要思想都差不多，第六-九章会进行详细讲解。
\par 第六章对同一性协议全景图进行了介绍，为后面章节对特定的同一性协议深入讨论做了个铺垫。这一章会讨论大多数同一性协议都会遇到的共性问题，包括缓存控制器和内存控制器的分布式操作，通用的MOESI同一性协议中的状态：修改中(modified, M)，占有(owner, O)，独占（exlusive, E），共享(shared, S)，非法(invalid, I)。 本章的一个重点是介绍用表驱动的方法对同一性协议的状态进行表征，包括稳态与瞬态。瞬态是需要的，因为现代系统极少提供从一种稳态原子转换到另外一种状态的能力（比如，对处于Invalid状态的数据进行读操作导致读未命中(read miss)，在变成 Shared 状态前，需要耗费一点时间等待数据响应）。很多同一性协议的实现复杂性被屏蔽在瞬态的过程中，这点类似于处理器复杂性被屏蔽在微架构状态中。
\par 第七章对商用中占主导地位的同一性协议：嗅探式同一性协议(snooping cache coherence protocols)，进行讨论。在简单的模型，snooping 协议是比较简单的。当cpu核心 遇到cache miss 发生时，它就在共享总线上发起仲裁，将其请求广播出去。共享总线的设计保证所有其连接的控制器接收到相同顺序的请求广播，这样，分布式的控制器就可以对他们各自的行动进行同步，进而能够保证全系统的状态是能够一致合理的。然而，现代系统中可能有多条总线，且总线不提供原子性处理请求的能力，总线内部还可能有仲裁请求暂存队列，并延迟、乱序发送请求，这些都使得snooping协议变复杂，也使得系统中可能出现更多种同一性瞬态。在结尾，第七章将实例学习 Sun UltraEnterprise E10000 和 IBM Power5。
\par 第八章将深入讨论目录式同一性协议(directory cache coherence protocols). directory 协议比snooping协议在多核可扩展性以及异构扩展性方面更有优势。计算机科学领域中有个笑话是，任何问题都可能通过增加中间层来解决。directory协议有点这个意思：某一个cache发生 read miss，将从它的下一级cache中获取该内存数据，而下一级cache中有个目录监视着哪些cache现在占有着哪些内存数据。根据目录项中记录的内容，缓存控制器(cache controller) 可能会直接回复请求者或者将请求消息继续转交给当前占有该内存数据的cache。可以看到在directory协议中，每条消息都有明确目的地(没有广播或多播动作)，但由于上述的转交操作，一次原始请求可能产生与内存操作节点成正比的请求消息，从而在系统中产生大量的瞬态。这一章先以一个简单的diretory协议开始，继而对其进行优化以使其能处理MOESI 中的E和O状态，可以进行分布式操作，更小的等待时延，（tbf）近似directory entry表示，等等。该章还探讨了directory同一性协议设计本身的一些技术点，包括directory缓存技术。最后，我们进行几个实例分析，包括（较旧） SGI Original 2000 和 （较新）AMD HyperTransport, HyperTransport Assist，以及 Intel QuickPath Interconnect (QPI) 。
\par 第九章讨论一些同一性进阶主题。前面几章在讨论同一性时有意地将场景限制在了简单的系统，以方便进行一些根本性问题的讨论。第九章深入讨论在复杂系统模型下的同一性协议及其优化问题，这些问题是snooping和directory都会遇到的。章节开始的主题包括指令缓存(instruction cache)，多级缓存(multilevel cache)，写直通缓存(write-through cache)，地址翻译缓存(translation lookside buffer, TLB)，同一性内存直连(coherent direct memory access, DMA)，虚拟缓存(virtual cache)，和多级同一性协议。（tbf）最后，章节对性能优化问题进行了讨论（比如针对migratory共享和false sharing进行优化）
\section {小测验}
你可能觉得自己对一致性和同一性有了足够的知识了解，没有必要继续再读本书了。为了验证你的感觉是否正确，我们准备了以下问题小测验。
\begin{itemize}
\item 问题 1： 在SC模型的系统中，处理器核心必须以程序指令顺序发送同一性请求。 对错？ （答案见3.8）
\item 问题2： 一致性模型定义了什么样的同一性请求操作顺序是正确的。 对错？ （答案见 3.8）
\item 问题3： 在进行原子读-改-写 (比如test and set)，处理器核总是需要与其它处理器核进行通信。对错？ （答案见 3.9）
\item 问题4： 在同时使用TSO模型和多线程处理器核（tbf  超线程？）的系统中，
\item 问题5： 程序员如果在高级语言一致性模型层面使用了恰当的同步机制，就无需再考虑内存系统上的一致性问题。对错？ （答案见 5.9）
\item 问题6： 在MSI snooping协议中，一个cache块只能处于三种状态中的一种状态。对错？ （答案见 7.2）
\item 问题7： snooping协议要求各个处理器核在总线上通信。对错？ （答案见 7.6）
\end{itemize}
\par 虽然答案在本书后面会揭晓，我们鼓励读者能在看答案前试着回答一下。
\section{本书无法提供什么}
\par 本书是一致性、同一性入门。我们期望的是本书第2-9章的每一章，以及进阶材料，是一节75分钟研究生课程教学量。为此，我们无法讨论所有一致性、同一性的问题，比如：
\begin{itemize}
\item 同步。同一性的目的是让缓存在程序功能上不可见。一致性的目标是使得系统中的所有共享内存像一个内存模块一样。但是程序员需要使用在必要的时候使用锁、barrier 及其它 的同步机制来使他们的程序能够正确运行、可用。
\item 商用弱序模型。本书没有详细讨论ARM和PowerPC的所有的内存序微妙行为，但我们会讨论使用什么的机制可以明确得到的什么样的内存序。
\item 并发编程。本书不涉及并发编程模型，方法论及其工具。
\end{itemize}
\chapter{同一性基础}






























\par















 











\end{document}
