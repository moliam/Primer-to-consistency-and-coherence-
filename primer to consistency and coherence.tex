\documentclass[UTF-8]{ctexbook}
\begin{document}
\title{内存一致性缓存一致性入门}
\author{Daniel J. Sorin, Mark D.Hill, David A.Wood 翻译：李默}
\date{2022.09.08}
\maketitle
\tableofcontents
\chapter*{摘要}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。对这样拥有共享内存的系统，它的内存一致性模型在架构上定义了它的内存组件能被观察到的行为的集合。一致性定义了读写操作的行为规则及它们如何与内存交互作用。为了实现所标称的一致性模型，一般这样的系统同时会使用特定的缓存一致性协议来保证多处缓存的数据时刻保持最新。 本入门手册的目的是为读者提供对内存一致性和缓存一致性模型的基本理解，包括技术问题与其解决方案。我们会在书中给出高度抽象的概念，同时也会给一些实际中的例子。
\par 注： 1. 内存一致性:  memory consistency，缓存一致性:  cache coherence. 二者的一致性的英文单词其实不同，所以其“一致”内涵实际有所不同。前者consistency字面意思是前后一致，即偏重时序上的行为特点，；而coherence 字面为协调，合理，所以更偏重在逻辑上的行为特点。但由于习惯用语，这里通用“一致性”。
\par 2. 文中如果出现“内存系统”或“内存”，如无特殊说明，指共享内存系统和共享内存，即具有多个处理器同时会访问操作的内存系统。

\chapter{内存、缓存一致性简介}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。这种使用多核心、共享内存的系统设计一般是想追求高性能、低功耗、低成本等等特性。当然，如果没有了基本的正确性，那这些特性也将无价值。共享内存正确性乍看好像很简单，但实际上，正如本书将展示的，共享内存的正确性定义甚至都不是一件简单事，存在很多模糊点，更不用说实现一个“正确”的共享内存。而且这些问题和模棱两可需要在硬件实现过程弄清楚，因为修复一个硬件bug的成本是很高的。学术的人也应该弄清，明确对象，这样才能讨论某个提议的设计是否能正常工作。
\par 在实际研究中我们发现在研究内存正确性时从两维度出发将有助于问题的分析与解决：consistency 与 coherence（注：下面会对这两个概念进行定义阐述）。一个系统并不是必须要区分此二者，只是从我们的经验上看，此二者可以帮助我们将问题分解，各个击破。实际上，在共享内存实现过程中，普遍采用了这两个维度的分解方法。
\par 共享内存的正确性主要由consistency维度来定义。consistency 的定义了读写如何作用到内存的规则。理想中consistency应该是一个简单的易于理解的模型。然而，定义共享内存的正确性比定义一个单核模型（即无需考虑并发共享）下的内存的正确性要模糊、朦胧地多。在单核模型下，内存正确性很好定义，这个正确性的行为可以与所有不正确性的行为有明确区分，这是因为在单核模型下，程序的输入具有明确的输出，即使这个cpu在内部执行时可能是乱序的，我们依然可以有明确的符合程序逻辑的预期输出。但对共享内存（即可能有多个处理器核心同时读写交互），它需要考虑来自多线程的并发读写，这种情况什么输出是正确的就不是唯一的，它可能会允许一些行为（即“正确”行为，是该内存模型下可能发生的行为），同时不允许另外一些行为（即“不正确”，是该内存模型承诺不会发生的行为）。之所以允许“一些”可能行为，而不是只允许“一种“行为，是因为在多线程并发读写的场景中无法明确这些线程在物理上孰前孰后，所以线程间可能有多种物理时序交错。多种正确可能性使得问题变得复杂，但要想在共享内存、多核系统上编写“正确”的程序，这些问题必须要得到解决。
\par 不同与consistency,  coherence（或缓存一致性）对软件是不可见的，也不需要可见。但作为支撑consistency 模型的一部分，大部分共享内存计算机系统都有一个coherence协议（因为大多系统也都有cache）。cache coherence 的目的是为了让共享内存系统的
cache行为和单核模型下的cache一样对外不可见，即不影响程序的功能。cache coherence协议的目的是让程序员不要从内存读写的结果上感受到cache的存在，不要让cache的存在引入任何功能性差异（当然，程序员可以从时间维度上探测cache的存在，但这不属于功能性差异）。
\par 通常，cache coherence在提供 consistency模型的过程中扮演非常重要的角色。因此，虽然consistency是本书的第一个主题，我们在第二章还是先对coherence进行一些介绍。本章的目标是先对coherence 和consistency的关系进行一些必要的描述，而不是深入具体的协议和实现（这些将在后面的章节 6-9中探讨）。第二章中，我们先使用SWMR(单写者多读者) 不变式来定义coherence。SWMR 不变式要求在任意时间任一内存位置要么只能在一个cache中接受写操作（同时也可以读操作），要么可以在多个cache中接受读操作。
\section{Consistency （译为：内存一致性、内存一致性模型，或内存模型) }
consistency模型定义了什么是“正确的”内存读取写入行为，而且这里的正确性与cache 或者cache coherence无关。为了更通俗地理解为什么需要consistency模型，我们举一个现实世界的例子。比如一个大学在网上发布它的课程表，其中计算机课程的上课地点是152教室。在上课的前一天，该大学管理人员决定将课程改至252教室上课。管理人员给网站管理员发送了email告诉他将网上的课程信息修改一下，几分钟后他还发短信给所有注册该课程的学生告知他们课程表更新的事情。不难预见，可能会有这样一种情形：网站管理员太忙碌没有及时发布新课表信息，而某位学生在接收短信后立即上网查看课表更新，此时该学生将看到教室还是152。虽然几分钟后管理员最终将课程教室更新至252，而且这位大学管理人员也进行了合理的“写”操作顺序（在他看来先通知管理员再通知学生是符合逻辑的），这位学生观察到的“写”操作顺序却是不同的，因此去了错误的教室。consistency模型就是定义是否这种系统行为（即管理人员先通知网络管理员更新网络，再通知学生，而学生先收到信息，之后再觉察网络更新）是“正确”的（此时用户需要采取其它措施以获取想要的结果），或是错误的（即系统实现将保证不会出现这种行为）。
\par 上述例子使用了多种信息传递介质，但类似的行为完全可能出现在同一介质的内存系统（下简称内存系统）中，尤其系统中还有多个能够乱序执行的cpu，内存系统有write buffer，具有预取能力，或者多cache bank机制。因此，我们需要定义内存系统的正确性，即何种内存行为是被允许的，这样程序员才会根据该正确性定义对系统的输出有正确的期望，内存系统的实现者也会有一个明确的行为约束。
\par 内存系统正确性是由内存一致性模型规格给出的（或简单称为内存模型）。内存模型明确规定了多线程、共享内存环境下被允许的行为集合。对一个处理某特定输入的多线程程序而言，内存模型规定了各个读取操作可能返回的值，以及内存的最终状态值。不同与单线程模式，在多线程模式下，可能有多种行为结果是被允许的，因而理解内存一致性模型也会稍微费劲些。
\par 第三章介绍了内存一致性模型的概念，同时介绍“顺序一致性模型”(Sequential Consistency，SC)，这是约束最强也是最直观的内存模型。章节开始先再次阐述下内存行为正确性定义的必要性，同时精确地定义什么是内存一致性模型。接着，章节深入讨论 SC模型。 SC模型规定，一个多线程程序运行的结果应该看起来像它的各个线程在单核cpu模型上在某种时间交错下分时运行的结果一样，这很直观、易于理解。在直观印象后，我们正式地对SC 进行讨论，同时探索下借助coherence用简单、激进两种方式实现一个SC 模型的过程 , 最终以MIPS R10000 实例学习作为结束。
\par 第四章中，我们在SC 基础上探索 x86 和 SPARC 处理器所使用的内存模型：全局写顺序一致性模型 (total store order, TSO) 。TSO 模型的要旨是在处理器将写操作正式提交给cache之前，先使用一个先入先出的写缓冲区来暂存这些提交的写操作。写缓冲区机制会违背SC 的行为约束，但由于TSO带来了可观的性能收益，所以人们决定还是允许这样一种内存模型的存在并对其进行了明确定义。在该章中，我们将探索如何用SC 的形式化方法来类似地研究TSO，TSO 如何影响内存系统的具体实现，以及对SC 和 TSO 进行比较。
\par 最终在第五章我们介绍弱一致性内存模型（下称弱序模型）。弱序模型提出的动机是那些强约束内存模型中大多内存操作序规格是不必要的。如果一个线程更新了十项数据，然后用一个同步flag进行标记 ，程序员其实不关心这十项数据哪项数据先更新哪项后更新，唯一关心的是同步flag 的标记动作需要在十项数据更新完成后再完成。弱序模型的目标是提供这种灵活的内存操作序以得到更高的性能或更简单的内存系统实现。在动机阐述后，该章提出了一个弱序模型例子，我们称其为XC。在XC中，程序员只有使用FENCE 指定才能得到明确的内存操作顺序，比如在数据更新 和同步 flag标记之间使用FENCE，以确保flag的完成在后。之后，该章继续扩充前面对SC 和 TSO 使用过的形式化方法，对XC 模型进行分析，以及探讨如何实现XC(包括各种乱序、coherence 协议等等)。接着我们讨论了一种很多程序员可以用来避免直接对弱序模型进行推理的方法：如果在程序中加入足够多的FENCE 指令以保证程序没有数据竞争（data race free, DRF）, 那么大多弱序模型将表现地类似SC 模型。 在这种无数据竞争的 “SC 模型”下，程序员可以同时获得（相对）SC的直观的正确性和(相对）XC 的高性能。对想深入了解的读者，该章最后将 "acquire/release" 做了区分，讨论了写原子性和因果性，还将涉及实际的商业化例子（包括一个 IBM Power 的例子）以及高级语言(Java和 C++)的内存模型。
\par 回想上面那个大学课程表的例子，我们可以看到email、网站管理员、短消息这些元素组成的系统其实是一个“弱序内存模型”。为了学生由于“过于及时”查看短信反而去到错误教室这种情况的发生，大学管理人员需要在发送email给网站管理员更新网页和 发送短信给学生之间插入一个FENCE 命令，以保证网站更新完成后学生才会收到短信。
\section{Coherence （译为： 缓存一致性）}
在多个内存操作者（如处理器）同时对一块数据区进行访问而且其中至少有一个写者时，如果不精心处理这些操作的交互，coherence问题将会发生。















 











\end{document}
