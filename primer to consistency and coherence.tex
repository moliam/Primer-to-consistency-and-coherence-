\documentclass[UTF-8]{ctexrep}
\usepackage{geometry}
\geometry{a4paper,scale=0.77}
\usepackage{tcolorbox}
\tcbuselibrary{skins, breakable, theorems}
\newtcolorbox{sidebarbox}{
    parbox=false,breakable,
    before upper=\par,
    before lower=\par
}
\begin{document}
\title{\textbf{A Primer on Memory Consistency and Cache Coherence}\\内存一致性与缓存同一性入门}
\author{Daniel J. Sorin, Mark D.Hill, David A.Wood \\翻译：李默 phylimo@163.com}
\date{2022.09}
\maketitle
\zihao{4}
\chapter*{\textbf{译注}}

\begin{enumerate}
\item consistency 和coherence 一般都统一译作“一致性”，即内存一致性、缓存一致性。但其实二者的“一致性”的英文单词不同，所以其“一致”内涵实际是不同的。本书使用稍微不同的翻译加以区分。
\par 前者consistency字面意思是前后一致，持续的一致，即偏重时序上的行为特点，采用常规“一致性”的译法；
\par 后者coherence 字面为协调，和谐，所以更偏重在逻辑上的行为特点，“cache coherence”的机制主要用于描述多个内存访问者对相同内存位置的操作是如何交互的，最理想的是在同一时刻，同一个数据、同一个值（但默认行为上一般不会如此严格，这会以损失性能为代价）。所以cache coherence是描述同数据是怎样保持同值的，故这里译作“同一性”。
\item 如无特殊说明，“一致性”将作为缩称代指内存一致性，“同一性”将作为缩称代指缓存同一性。
\item 如无特殊说明，文中如果出现“内存系统”或“内存”，指共享内存系统和共享内存，即多个操作者（如处理器，外设等等）同时会访问操作的内存系统。
\end{enumerate}

\tableofcontents
\chapter*{摘要}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。对这样拥有共享内存的系统，它的内存一致性模型在架构上定义了它的内存组件能被观察到的行为的集合。一致性定义了读写操作的行为规则及它们如何与内存交互作用。为了实现所标称的一致性模型，一般这样的系统同时会使用特定的缓存同一性协议来保证多处缓存的数据时刻保持最新。 本入门手册的目的是为读者提供对内存一致性和缓存同一性模型的基本理解，包括技术问题与其解决方案。我们会在书中给出高度抽象的概念，同时也会给一些实际中的例子。

\CTEXsetup[format={\Large\bfseries}]{section}
\chapter{内存一致性、缓存同一性简介}
许多现代计算系统及多核处理器芯片在硬件上都支持共享内存。在有共享内存的系统中，不同的处理器核心可能对同一内存地址空间进行读写操作。这种使用多核心、共享内存的系统设计一般是想追求高性能、低功耗、低成本等等特性。当然，如果没有了基本的正确性，那这些特性也将无价值。共享内存正确性乍看好像很简单，但实际上，正如本书将展示的，共享内存的正确性定义甚至都不是一件简单事，存在很多模糊点，更不用说实现一个“正确”的共享内存。这些问题需要在硬件实现过程弄清楚，因为修复一个硬件bug的成本是很高的。学术的人也应该弄清，明确对象，这样才能讨论某个提议的设计是否能正常工作。
\par 在实际研究中我们发现在研究内存正确性时从两维度出发将有助于问题的分析与解决：consistency 与 coherence（一致与同一，下面会对这两个概念进行定义阐述）。当然一个系统并不是必须要区分此二者，只是从我们的经验上看，此二者有助于我们将问题分解，各个击破。实际上，在内存系统实现过程中，普遍采用了这两个维度的分解方法。
\par 共享内存的正确性主要由一致性维度来定义，一致性模型定义了读写如何作用到内存的规则。理想情况下，一致性模型应该是一个简单的易于理解的模型（或规格说明）。然而，定义共享内存的正确性比定义一个单核模型（即无需考虑并发共享）下的内存的正确性要模糊、朦胧地多。在单核模型下，内存正确性很好定义，它有一个唯一正确性结果，可以与所有不正确性的行为明确区分，这是因为在单核模型下，程序的输入具有明确的输出，即使这个cpu在内部执行时可能是乱序的，我们依然可以有明确的符合程序逻辑的预期输出。但对共享内存（即可能有多个处理器核心同时读写交互），它需要考虑来自多线程的并发读写，这种情况哪种输出是正确的就不是唯一的，它可能会允许一些行为（即“正确”行为，是该内存模型下可能发生的行为），同时不允许另外一些行为（即“不正确”，是该内存模型承诺不会发生的行为）。之所以允许“一些”可能行为，而不是只允许“一种“行为，是因为在多线程并发读写的场景中无法明确这些线程在物理上孰前孰后，所以线程间可能有多种物理时序交错。这种正确性多样化使得问题变得复杂，但要想在共享内存、多核系统上编写“正确”的程序，这些问题必须要得到明确地解决。
\par 与内存一致性不同, 缓存同一性对软件是不可见的，也不需要可见。但作为支撑一致性模型的一部分，大部分共享内存计算机系统才会使用某种同一性协议（因为大多系统也都使用了缓存）。同一性的目的是为了让共享内存系统的缓存行为和单核模型下的缓存一样对外不可见，即不影响程序的功能。所以，同一性协议的目的是让用户无法从读写的数值结果上感受到缓存的存在，避免缓存的使用引入任何功能性差异（当然，程序员依然可以从时间维度上探测缓存的存在，但这不属于功能性差异）。
\par 一般来说，同一性在支撑一致性模型的过程中扮演非常重要的角色。因此，虽然一致性是本书的第一个主题，我们在第二章还是先对同一性进行一些介绍。本章先对一致性与同一性的关系进行一些必要的介绍，而不是直接深入具体的协议和实现（这些将在后面的章节6-9中探讨）。第二章中，我们先使用SWMR(单写者多读者) 不变式来定义同一性。SWMR 不变式要求在任意时间任一内存位置要么只能在一个缓存中接收写操作（同时也可以在该缓存中接收读操作），要么可以在多个缓存中接受读操作。
\section{一致性}
\par 一致性亦称内存一致性、内存一致性模型，或内存模型。一致性模型定义了什么是“正确的”内存读取写入行为，而且这里的正确性与缓存及缓存同一性无关。为了更通俗地理解为什么需要一致性模型，我们举一个现实世界的例子。比如一个大学在网上发布了它的课程表，其中计算机课程的上课地点是152教室。在上课的前一天，该大学管理人员决定将课程改至252教室上课。管理人员首先给网站管理员发送了email告诉他将网上的课程信息更新，不久后他发短信给所有注册该课程的学生告知他们课程表更新的事情。不难预见，可能会有这样一种情形：网站管理员太忙碌没有及时更新课表信息，而某位学生在接收短信后立即上网查看“新”课表，此时该学生将看到教室还是152。虽然几分钟后管理员最终将课程教室更新至了252，而且这位大学管理人员(从他的视角看)也进行了正确的“写”操作顺序，但这位学生观察到的“写”操作顺序却是不同的，导致最终去了错误的教室。一致性模型就是定义在这样的系统中这种行为表现（即管理人员先通知网络管理员更新网络，再通知学生;而学生则是先收到信息，之后才觉察网络更新）是“正确”的（此时用户需要采取其它措施以获取想要的结果），或是错误的（即系统实现将保证不会出现这种行为表现）。
\par 上述例子使用了多种信息传递介质，但类似的行为完全可能出现在同一介质的内存系统中，尤其系统组成中有多个能够乱序执行的cpu，或内存系统有write buffer，具有预取能力，或者多cache bank机制。因此，我们需要定义内存系统的正确性，即何种内存行为是被允许的，这样程序员才会根据该正确性定义对系统的输出有正确的期望，内存系统的实现者也会有一个明确的行为约束准则。
\par 内存系统正确性由内存一致性模型给出。一致性模型明确规定了多线程、共享内存环境下被允许的行为集合。对某处理某特定输入的多线程程序而言，内存模型规定了其各个读取操作可能返回的内存值，以及内存可能的最终状态。不同与单线程模式，在多线程模式下，可能有多种行为结果是被允许的，因而理解内存一致性模型也会稍微复杂。
\par 第三章介绍了内存一致性模型的概念，同时介绍“顺序一致性模型”(Sequential Consistency，SC)，这是约束最强也是最直观的一致性模型。章节伊始再次阐述了内存正确性定义的必要性，同时精确地定义什么是内存一致性模型。接着，章节深入讨论SC模型。SC模型规定，一个多线程程序运行的结果应该看起来像它的各个线程各自按程序指令顺序执行，线程间又以某种时间交错方式下分时复用单核心处理器运行的结果一样，很直观、易于理解。在直观印象后，我们用形式化语言正式地对SC进行讨论，同时探索了在有缓存机制的情况下较简单较复杂两种方式实现SC模型的过程 , 最终以MIPS R10000 实例学习作为结束。
\par 第四章，我们在SC 基础上研究 x86 和 SPARC 处理器所使用的内存模型：全局写序一致性模型 (total store order, TSO) 。TSO 模型的要旨是在处理器将写操作正式提交给缓存之前，先使用一个先入先出的写缓冲区来暂存这些提交的写操作。写缓冲区的引入将违背SC模型定义，但由于TSO模型可以带来明显的性能收益，所以人们还是允许这样一种内存模型的存在并对其进行了明确定义。在该章中，我们还将探索如何用SC的形式化方法来类似地研究TSO模型，TSO模型如何影响内存系统的具体实现，以及对SC 和 TSO 进行比较。
\par 最后，在第五章我们引入弱序一致性模型（简称弱序模型）。弱序模型提出的动机是那些强约束一致性模型中对大多内存操作的序的限制是不必要的。如果一个线程更新了十项数据，然后用一个同步flag进行标记与其它线程同步，程序员其实不关心这十项数据哪项数据先更新哪项后更新，唯一关心的是同步flag的标记动作需要在十项数据更新完成后再完成。弱序模型的目标正是提供这种灵活的内存操作序以得到更高的性能或更简单的内存系统实现。阐述了动机后，我们提出了一个名为XC的弱序模型示例。在XC中，程序员只有使用FENCE指定才能得到明确的内存操作顺序，比如在数据更新和同步flag标记之间使用FENCE，以确保flag的完成在数据更新之后。之后，该章延续使用前面对SC 和 TSO 使用过的形式化方法，对XC模型进行分析，以及探讨如何实现XC (包括各种乱序、同一性协议等等)。接着我们讨论了一种很多程序员可以用来避免直接对弱序模型进行推理的做法：如果在程序中加入足够多的FENCE指令以保证程序没有数据竞争（data race free, DRF）, 那么大多弱序模型将表现地类似SC模型。 在这种无数据竞争的类“SC模型”下，程序员可以兼得（相对）SC的直观的正确性和(相对）XC的高性能。对想深入了解的读者，该章最后将"acquire/release" 做了区分，讨论了写原子性和因果性，还将涉及一些商业产品例子（包括一个 IBM Power 的例子）以及高级语言(Java和 C++)的内存模型。
\par 回想上面大学课程表的例子，我们可以看到email、网站管理员、短消息这些元素组成的系统其实是一个“弱序模型”。为了学生由于“太及时”查看短信反而去到错误教室这种情况的发生，大学管理人员需要在发送email通知网站管理员更新网页和发送短信给学生之间插入一条FENCE命令，以保证网站更新完成后学生才会收到短信。
\section{同一性}
\par 同一性即缓存同一性。在有缓存的系统中，多个内存操作者（如处理器、可直接访问内存的外设等等）同时对一块数据区进行访问而且其中有写操作时，如果不精心处理这些并发操作的交互，同一性问题将会发生。举一个与前面用过的课程表类似的例子：一位同学上网查看了课程表信息，看到上课地点是152教室（数据读取），记在了自己的本子上(数据缓存)。接着管理员将上课地点改到252教室，并及时更新了网页内容。此时，这位同学自己本子上的数据是过期的了，这时就遇到了“不同一” 的场景。如果同学到152去，他会发现进错了教室。计算机的世界里（不包括计算架构），“不同一” 的例子有网页缓存、使用未更新代码库编程等等。
\par 同一性协议就是为了避免这种获取到过期数据的情况出现，它是所有参与者都共同遵循的一系列规范。同一性协议可能有很多变种形式，但其主要思想都差不多，第六-九章会进行详细讲解。
\par 第六章对同一性协议全景图进行了介绍，为后面章节对特定的同一性协议深入讨论做了个铺垫。这一章会讨论大多数同一性协议都会遇到的共性问题，包括缓存控制器和内存控制器的分布式操作，通用的MOESI同一性协议中的状态：修改中(modified, M)，占有(owner, O)，独占（exlusive, E），共享(shared, S)，非法(invalid, I)。 本章的一个重点是介绍用表驱动的方法对同一性协议的状态进行表征，包括稳态与瞬态。瞬态是需要的，因为现代系统极少提供从一种稳态原子转换到另外一种状态的能力（比如，对处于Invalid状态的数据进行读操作导致读未命中(read miss)，在变成 Shared 状态前，需要耗费一点时间等待数据响应）。很多同一性协议的实现复杂性被屏蔽在瞬态的过程中，这点类似于处理器复杂性被屏蔽在微架构状态中。
\par 第七章对商用中占主导地位的同一性协议：嗅探式同一性协议(snooping cache coherence protocols)，进行讨论。在简单的模型，snooping 协议是比较简单的。当cpu核心 遇到cache miss 发生时，它就在共享总线上发起仲裁，将其请求广播出去。共享总线的设计保证所有其连接的控制器接收到相同顺序的请求广播，这样，分布式的控制器就可以对他们各自的行动进行同步，进而能够保证全系统的状态是能够一致合理的。然而，现代系统中可能有多条总线，且总线不提供原子性处理请求的能力，总线内部还可能有仲裁请求暂存队列，并延迟、乱序发送请求，这些都使得snooping协议变复杂，也使得系统中可能出现更多种同一性瞬态。在结尾，第七章将实例学习 Sun UltraEnterprise E10000 和 IBM Power5。
\par 第八章将深入讨论目录式同一性协议(directory cache coherence protocols). directory 协议比snooping协议在多核可扩展性以及异构扩展性方面更有优势。计算机科学领域中有个笑话是，任何问题都可能通过增加中间层来解决。directory协议有点这个意思：某一个cache发生 read miss，将从它的下一级cache中获取该内存数据，而下一级cache中有个目录监视着哪些cache现在占有着哪些内存数据。根据目录项中记录的内容，缓存控制器(cache controller) 可能会直接回复请求者或者将请求消息继续转交给当前占有该内存数据的cache。可以看到在directory协议中，每条消息都有明确目的地(没有广播或多播动作)，但由于上述的转交操作，一次原始请求可能产生与内存操作节点成正比的请求消息，从而在系统中产生大量的瞬态。这一章先以一个简单的diretory协议开始，继而对其进行优化以使其能处理MOESI 中的E和O状态，可以进行分布式操作，更小的等待时延，（tbf）近似directory entry表示，等等。该章还探讨了directory同一性协议设计本身的一些技术点，包括directory缓存技术。最后，我们进行几个实例分析，包括（较旧） SGI Original 2000 和 （较新）AMD HyperTransport, HyperTransport Assist，以及 Intel QuickPath Interconnect (QPI) 。
\par 第九章讨论一些同一性进阶主题。前面几章在讨论同一性时有意地将场景限制在了简单的系统，以方便进行一些根本性问题的讨论。第九章深入讨论在复杂系统模型下的同一性协议及其优化问题，这些问题是snooping和directory都会遇到的。章节开始的主题包括指令缓存(instruction cache)，多级缓存(multilevel cache)，写直通缓存(write-through cache)，地址翻译缓存(translation lookside buffer, TLB)，同一性内存直连(coherent direct memory access, DMA)，虚拟缓存(virtual cache)，和多级同一性协议。（tbf）最后，章节对性能优化问题进行了讨论（比如针对migratory共享和false sharing进行优化）
\section {小测验}
你可能觉得自己对一致性和同一性有了足够的知识了解，没有必要继续再读本书了。为了验证你的感觉是否正确，我们准备了以下问题小测验。
\begin{itemize}
\item 问题 1： 在SC模型的系统中，处理器核心必须以程序指令顺序发送同一性请求。 对错？ （答案见3.8）
\item 问题2： 一致性模型定义了什么样的同一性请求操作顺序是正确的。 对错？ （答案见 3.8）
\item 问题3： 在进行原子读-改-写 (比如test and set)，处理器核总是需要与其它处理器核进行通信。对错？ （答案见 3.9）
\item 问题4： 在同时使用TSO模型和多线程处理器核（tbf  超线程？）的系统中，
\item 问题5： 程序员如果在高级语言一致性模型层面使用了恰当的同步机制，就无需再考虑内存系统上的一致性问题。对错？ （答案见 5.9）
\item 问题6： 在MSI snooping协议中，一个cache块只能处于三种状态中的一种状态。对错？ （答案见 7.2）
\item 问题7： snooping协议要求各个处理器核在总线上通信。对错？ （答案见 7.6）
\end{itemize}
\par 虽然答案在本书后面会揭晓，我们鼓励读者能在看答案前试着回答一下。
\section{本书无法提供什么}
\par 本书是一致性、同一性入门。我们期望的是本书第2-9章的每一章，以及进阶材料，是一节75分钟研究生课程教学量。为此，我们无法讨论所有一致性、同一性的问题，比如：
\begin{itemize}
\item 同步。同一性的目的是让缓存在程序功能上不可见。一致性的目标是使得系统中的所有共享内存像一个内存模块一样。但是程序员需要使用在必要的时候使用锁、barrier 及其它 的同步机制来使他们的程序能够正确运行、可用。
\item 商用弱序模型。本书没有详细讨论ARM和PowerPC的所有的内存序微妙行为，但我们会讨论使用什么的机制可以明确得到的什么样的内存序。
\item 并发编程。本书不涉及并发编程模型，方法论及其工具。
\end{itemize}
\chapter{同一性基础}
本章我们对同一性进行必要的介绍，以能够让大家理解一致性和同一性是如何相互作用的。在2.1中我们先介绍我们将在本书贯穿使用的基础系统模型。为了使讲解更简明扼要，我们选择了最简单但又能将主要问题阐述清楚的系统模型。直到第九章我们再进行复杂系统模型下的一致性同一性讨论。2.2对同一性问题进行了解释，这些问题是同一性所必须的解决的，并讨论了可能导致“不同一”的场景。
\section{系统模型}
在本书中，我们考虑具有多核处理器与共享内存的系统。每个处理器核都可以对所有（物理）内存位置进行读写操作。我们构造的系统模型中只含有一个多核处理器，一个与处理器不共芯片的内存，见图2.1。这里的多核处理器是指有多个单线程核（即，不包括超线程等技术），每个核都有本地私有数据缓存，而后所有的核还共享有一个末级缓存(last-level cache, LLC)。如非特殊说明，本书中使用缓存(cache)时指的是核的私有缓存，非LLC。每个核都使物理地址对缓存访问，缓存类型是“写回”(write-back)。核与LLC之间通过互通网络来通信。虽然LLC缓存是处理器芯片上的组件，它其实可以看作是内存侧的缓存，因此它的引入并未对缓存同一性带来新问题。逻辑上，LLC的作用只不过是内存的前端，降低内存访问的平均迟延，同时提升内存有效带宽。当然，LLC还有一个作用是处理器片上的内存控制器。
\par 我们使用的系统模型省略了很多常见的组件及特性，不过它们对本书的讲解无关紧要。这些组件包括：指令缓存(instruction cache)，多级缓存(multiple-level cache)，多核共享缓存，虚拟地址缓存，地址翻译缓存（TLB），内存直连等（DMA）等。模型中也不包括多个多核处理。在本书后面特性组件会被讨论，但暂时我们先忽略以避免引入不必要的复杂性。
\section{“不同一”的产生}
“不同一”的产生都是由于同一个根因：缓存、内存有多个操作者。在现代系统中，这些操作者是处理器核，DMA引擎，以及一些可以对缓存、内存进行访问的外设。在本书我们主要关注的操作者是处理器核，但要知道实际中其它类型的操作也是存在的。
\par 图2.2简单示意了不同一的产生。初始时，内存地址A的内存值为42，核1与核2都将A读到了他们各自的私有缓存中。在时刻3时，核1将它私有缓存中的A的值进行了加1操作变为43，这使得核2缓存中的A值过期，导致“不同一”。为了避免这种不同一，系统需要实现一套同一性协议来控制核2不能在核1观察到43的时候依然还观察到42。同一性协议的设计与实现是第7-9章的主要内容。
\section{同一性定义}
图2.2中“不同一”的场景直观理解应该是属于“错误”的行为，有了直观感觉后，本小节中我们将给出同一性严格的定义。在各种教科书和文献中，同一性的定义有多种多样。我们不打算全部讲解它们，而是给出我们偏向于使用的一个定义，因为它点明了同一性的要旨。在阅读角中，我们讨论一点其它的同一性定义，以及它们与我们的定义的关系。
\par 我们对同一性的定义的基础概念是单写多读（或单写者多读者，single-writer-multiple-reader, SWMR）不变式。对任一内存地址 ，在任一时刻（注1），要么只有一个核可以写入（当然这个核也可以读），要么有多个核在进行读取。所以在任一时刻，不能一个核在写，而有另外一个核在读或写。上述描述也可以换一种方式理解：将内存地址的“生命周期”用代（epoch）来表征。在一个epoch里，要么只有一个核有读写访问权限，要么有多个核（也可能是0）同时有只读访问权限。图2.3给出了保持SWMR不变式的包含4个代际的内存地址生命周期变化。
\par 除了SWMR，同一性还要求内存值的广播是正确的。简单解释下内存值正确性为什么是必需的。比如上面图2.3中，虽然epoch上SWMR不变式得到了保持，但在第一个只读epoch中核2与核5如果对该内存读取到不同的值，那么系统将是“不同一”的。类似地，如果核1没有获取到核3在该内存read-write epoch的时候写入的值，或者核1，2，3没有获取到核1在该内存read-write epoch中写入的值，系统也将进入“不同一”状态。
\par 因此同一性定义需要在SWMR不变式的基础上加入值的某种不变式才能完整，这个不变式是关于内存值是如何从一个epoch向下一个epoch传播：在一个epoch开始时，某内存位置的内存值需要等于它最近一次在read-write epoch结束时的值。
\par 这些不变式其实有一些不同的等价描述，其中有个著名的是将SMWR用令牌来描述。描述如下：对每个内存地址，都配有至少与处理器核数量等量的令牌。对一个内存地址，如果一个核拥有其全部令牌，它可以对内存地址进行写操作，如果一个核有一个或多个令牌，它可以进行读操作。通过这样的设置，可以保证在任一时间，不可能有一个核在对某地址写入而其它核在读或写该地址。
\par 注1：SWMR不变式只要求在逻辑时间(logical time)域上被遵守，而是物理时间。这个微小的区别使得我们可以做很多优化，有的优化看起来好像破坏了不变式，但实际没有。关于优化部分我们将推迟到后面的章节讲解，如果读者对逻辑时间不熟悉不要担心。
\begin{sidebarbox}
\centerline{\textbf{同一性不变式}}
\begin{enumerate}
\item \textbf{单写多读不变式。} Single-Write, Multiple-Reader(SWMR) invariant。对任一内存地址A，在任一（逻辑）时刻，要么只有一个核可以写入（这个核也可以读），要么有不定数量的核可以读取A。
\item \textbf{值不变式。} 在一个epoch开始时，某内存位置的内存值需要等于它最近一次在read-write epoch结束时的值。
\end{enumerate}
\end{sidebarbox}
\subsection{同一性不变式的保持}
在前面小节中，我们通过同一性不变式对同一性协议是如何工作进行了直观的介绍。实际上大部分同一性协议的设计内容就是在维持这些不变式，这类协议称为“使无效协议”(invalidate protocol)。一个处理器核在读取某内存位置内容时，它会先发消息给其它核来获取当前该内存位置的值，同时也是为了确保不存在其它核对该内存位置的缓存正处于读写状态。该消息会终止（使无效）所有对该内存位置活跃的读写epoch，并开始一个新只读epoch。如果一个核要向某内存位置写入数据，若它还未持有该内存位置的一个可用只读缓存，它将发送消息给其它核来获取当前的内存值，并确保不存在其它核对该内存有合法的只读或读写的缓存状态。这样的消息会终止（使无效）所有对该内存位置正在活跃的读写或只读epoch，并开启新的读写epoch。本书第6-9章会针对“使无效”类协议上面的这些笼统操作展开详述，但直观表现上它们是一样的。
\subsection{同一性的粒度}
处理器核能够以不同粒度进行读写，一般粒度从1字节到64字节不等。理论上，同一性协议可以在最小的读写粒度上进行，但实践中同一性协议一般在缓存块(cache block)的粒度进行。换句话说，处理器硬件一般提供的是缓存块的同一性。而SWMR的操作对象也从对某内存“位置”变成了某内存“块”，也就是说在现实系统中，一般不会发生一个核对某内存块的首字节在写，而另一核同时在对该内存块的中间字节在写入。尽管基于“块”的同一性是普遍的，而且也是我们本书中使用的模型，我们还是要知道更小粒度或更大粒度的同一性协议都是存在的。
\begin{sidebarbox}
\par 同一性的类“一致性”描述
\par 上面我们对同一性定义所使用的不变式是关于处理器核在何种条件下能够拥有何种访问权限，以及数据如何在核间传播的。除此外，还有另外一类对同一性的定义，它的侧重点是读写操作关系本身，有点类似于一致性模型对可感知的读写序行为的定义。
\par 这一类描述中，有一种描述与顺序模型(SC)有相通处。我们在第三章中将深入讨论SC模型，它要求系统的内存变化过程如同所有线程的所有内存读写操作按照程序指令序以某种时域交错执行的一样（线程间交错，线程内遵守程序指令序），所以它是一种时序上的“全序关系”模型。在SC系统中，全序关系中的任一读操作的结果是序关系中最近的一次写操作的结果。用类“SC”的描述方法定义的同一性是这样的：一个具有同一性的系统中，某特定内存位置的变化过程如同所有线程各自按程序指令序对该位置进行读写，并线程间以某种时域交错执行一样。可以看到该定义指出了一致性与同一性的重要区别点：同一性描述的是特定内存位置值的变化过程，而一致性描述不同内存位置值的变化过程尤其不同位置值变化的时间关系。
\par 还有一种对同一性的定义也是使用了两个不变式：(1) 每个写操作最终都会被所有核观察到  (2) 对同内存位置的写操作是串行进行的（即，所有核观察到的该内存位置值的变化过程是相同的）。IBM在Power中使用了类似的定义以使得其硬件实现更加容易，因为该模型允许一个核对某内存位置的写操作先通知到一些核（这些核可以通过读操作观察到值的变化），而后通知到另一些核。
\par 另外一种同一性定义是Hennessy与Patterson所使用的，它有三个不变式：(1) 内存位置A的读返回的该核最近一次写入的值，除非在该核上次写与本次读之间其它核对该位置进行了写操作 (2)  一个核对A位置进行了写操作S,  足够长时间后，另外一个核对A位置进行读操作将返回S写入的值，除非在S和这次读之间还有其它写入操作  (3) 对同内存位置的写入是串行的（与前一种定义的不变式\#2相同）。这组不变式集合的描述很直观，但其中“足够长时间后”可能会引起一些问题，因为它不是一个精确的术语。
\par 上面这些“类一致性”定义和我们在2.3中使用的定义是等价的，它们可以用来判断给定的同一性协议是否足以使一个系统“同一”。一个正确的同一性协议会满足所有的定义形式。但是类一致性描述不能给同一性协议设计者太多的直观理解，他们在设计协议的时候考虑的是规范处理器何时、如何可以访问内存，所以我们认为2.3的定义对他们来说更具有启发性。
\end{sidebarbox}
\subsection{同一性的作用范围}
同一性的定义-无论我们采用哪种定义-都是有特定适用范围的，设计必须清楚什么时候需要考虑同一性、什么时候不需要。我们讨论两个重要的适用范围：
\begin{itemize}
\item 同一性适用于所有持有共享内存块的存储结构器件。这些器件包括L1数据缓存，L2缓存，LLC，和主存，另外还包括L1指令缓存和地址翻译缓存（TLB）。
\item 同一性不属于架构组件（即，同一性不是架构可感知元素）。严格来说，一个系统即使处于“不同一”的状态，只要遵守它的一致性模型要求，那么它依然是“正确”的（因为正确本身就是一致性定义的）。这个问题可能有点玄乎（有点难想象一个现实系统遵守一致性而未保持同一性是怎样的），但它有个非常重要的推论：内存一致性模型对内存同一性模型没有任何约束。尽管如此，如第3-5章将讲述的一样，许多一致性模型的具体实现依赖了某种同一性模型来保证其正确性，这也是我们先在本章进行同一性讲解，再后面章节讲一致性的原因。

\end{itemize}
\section{参考文献}
(tbf)
\begin{thebibliography}{99}
\bibitem{ref1}K. Gharachorloo. Memory Consistency Models for Shared-Memory Multiprocessors. PhD thesis, Computer System Laboratory, Stanford University, Dec. 1995.
\bibitem{ref2}K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. Memory Consistency and Event Ordering in Scalable Shared-Memory. In Proceedings of the 17th
Annual International Symposium on Computer Architecture, pp. 15–26, May 1990.
\bibitem{ref3}J. L. Hennessy and D. A. Patterson. Computer Architecture: A Quantitative Approach. Morgan Kaufmann, fourth edition, 2007.
\bibitem{ref4}IBM. Power ISA Version 2.06 Revision B. http://www.power.org/resources/downloads/PowerISA\_V2.06B\_V2\_PUBLIC.pdf, July 2010.
\bibitem{ref5}M. M. K. Martin, M. D. Hill, and D. A. Wood. Token Coherence: Decoupling Performance and Correctness. In Proceedings of the 30th Annual International Symposium on Computer Architecture, June 2003. doi:10.1109/ISCA.2003.1206999
\end{thebibliography}




\chapter{一致性的由来以及顺序一致性模型}
本章深入讨论内存一致性模型。一致性模型定义了拥有它的共享内存的“正确”行为，这样程序员就可以依赖此并对程序执行的结果有预估，实现者也可以依此进行有目的的设计。我们先对一致性模型的由来进行介绍（3.1），然后讲解一致性模型包括哪些内容（3.2），最后比较一致性与同一性（3.3）。
\par 然后，我们介绍下（相对而言）比较直观的一致性模型：顺序一致性模型（sequential consistency, SC）。SC非常重要，因为大多数程序员对共享内存的行为期待其实都是SC，它也是理解更宽松的一致性模型（弱序一致性模型，接下来两章将进行讨论）的基础。我们先介绍SC的核心思想（3.5），再讨论几种SC的实现，包括初级实现（tbf， 3.6，operational mode），有缓存同一性的简单实现(3.7)，有缓存同一性的优化版实现（3.8），和原子操作实现（3.9）。最后我们以MIPS R10000为实例讨论SC，然后提供一些深入阅读学习建议。
\section{共享内存带来的问题}
让了使大家明白“定义共享内存的正确行为”这件事的必要性，我们看表3.1中的例子（如非特殊说明，本书使用的例子都假设所有变量的初始值为0），表中是两个处理核的执行流。大多数程序员都期待核C2的寄存器r2获取的值是NEW。然而，在现今有些系统中，r2的值可能是0。
\par 之所以r2可能获得值0，是因为在硬件层面C1的写操作S1和S2可以乱序执行。从本地视角看（即只关注C1的执行，不考虑其与其它核的交互），这种乱序看起来是正确的，因为S1和S2访问的不同的内存位置。正面的sidebar列举了一些硬件可能乱序的内存访问操作，包括上面的写-写操作。非硬件专家最好心中有数，这些乱序是可能发生的（即，缓存的写操作buffer不是写入写出的）。
\par 由于S1与S2的乱序，系统的执行序列可能是S2，L1，L2，S1，如表3.2表示。该乱序执行依然满足同一性，因为SWMR未被破坏，所以同一性不是该问题的原因。
\begin{sidebarbox}
\centerline{\textbf{阅读角：内存操作的乱序（或重排序）}}
\par 本阅读角列举了现代处理器核心对不同内存地址的操作可能乱序执行的方式。对硬件概念不熟悉的读者可以暂时跳过，后面再回来阅读。现代处理器的核心可以乱序执行多个内存访问操作，但以两个内存操作的序关系对核心概念的讲解就足够了。绝大多数情况下，我们只需要对不同地址的内存访问的序进行讨论，因为SC模型一般要求一个处理器核中对同一地址的内存操作是以原程序指令顺序进行的。根据内存操作的读、写类型不同，我们将可能的乱序分解为以下有三种：
\par \textbf{写-写乱序（store-store reordering）}。如果处理器核的写操作buffer不是先入先出（FIFO）的，那么对两个不同地址的写操作将有可能被乱序，与他们在原程序中的指令序产生颠倒。这种情况可能发生在前面的写操作产生了缓存未命中，或者后面的写操作与更前面的写操作合并操作了。（tbf，跳过一句）。不同内存地址之间的操作乱序对单线程的执行是没有影响的。但在表3.1的多线程执行的例子中，核C1的乱序执行让核C2先于data的变化观察到了flag变为SET的变化。这种乱序即使使用最完美的同一性（如严格地立即值同步的内存）也无法修正。同一性只是让cache的缓存效果不被感知，但这里的写操作已经乱序了。
\par \textbf{读-读乱序（load-load reordering）}。如前所述，现代动态指令调度的处理器核可能以不同于代码指令的顺序执行程序，即乱序执行。在表3.1中，核C2可能乱序执行读操作L1和L2。对单线程程序而言，这种乱序不会引发什么问题，因为它们指向不同的位置。但在多线程场景下，如表3.1，核C2的乱序可能导致与核C1乱序类似的结果，比如系统的全局序列为L2，S1，S2，L1，那么r2的值也会是0。如果把判断B1去掉，L1和L2之前不再有条件依赖，这种情况会更明显。
\par \textbf{读-写乱序（load-store reordering）和写-读乱序（store-load reordering）}。来自同一线程的读操作和写操作也可能被乱序（如果它们指向不同的内存位置）。读-写乱序可能导致很多奇怪的（看似不正确）的行为，比如可能导致保护资源的锁释放后再对该资源进行读取。表3.3则示例了写-读乱序。如果核C1的S1、L1及核C2的S2、L2都乱序，则会产生非常反直觉的结果：r1和r2都为0。即使处理器核按照指令原顺序执行，写-读乱序依然可能在有FIFO式写缓存机制时发生。
\par 读者可能默认硬件不应该让上面的行为或某种行为发生，但在未完整了解硬件真正允许的行为前，不能这样默认。
\end{sidebarbox}


\par 让我们再看另外一个例子，该例子由Dekker的互斥锁算法启发而来。













\par















 











\end{document}
